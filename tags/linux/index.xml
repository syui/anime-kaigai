<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on アニメ海外反応</title>
    <link>https://anime.syui.cf/tags/linux/index.xml</link>
    <description>Recent content in Linux on アニメ海外反応</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>Powered by [Hugo](//gohugo.io). Theme by [term](https://gitlab.com/syui/hugo-theme-term).</copyright>
    <atom:link href="https://anime.syui.cf/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>デスクトップ・カスタマイズ</title>
      <link>https://anime.syui.cf/2016-10-17-desktop</link>
      <pubDate>Mon, 17 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://anime.syui.cf/2016-10-17-desktop</guid>
      <description>&lt;p&gt;それぞれのOSで使っているデスクトップアプリとその使い方など。デスクトップと言っても私はほとんどCLIしか使いませんので、多くはCLI Toolと補助アプリになります。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;私は主にArch Linux, macOS, Windows10のデスクトップを使います。Windows10だけはVirtualBoxで構築したものを主に使いますが、殆どは実機かVPN上に構築しています。&lt;/p&gt;

&lt;p&gt;それぞれのOSには特徴が異なりますが、基本的なことはどのデスクトップでも可能になっているので、それほど違いはありません。&lt;/p&gt;

&lt;p&gt;私の印象で言うとLinuxのデスクトップは自由度が高くコマンドライン系のアプリが多く、非常に扱いやすい印象です。反対にデザイン系のアプリは少なく、X上で再現されるため非常に貧弱です。&lt;/p&gt;

&lt;p&gt;macはUnixの上に構築されているので、Unixコマンドが便利です。また、UIに強いこだわりがあり、そのためかデザイン系のアプリが豊富です。&lt;/p&gt;

&lt;p&gt;Windowsは昔からあるOSでユーザーが多かったことから様々なGUIアプリが豊富です。しかし、コマンドラインが貧弱です。&lt;/p&gt;

&lt;p&gt;このような違いが出てくるのは主にユーザーの数や特徴によります。&lt;/p&gt;

&lt;p&gt;現在一番バランスが良いのはmacです。殆どの主要アプリは移植され、コマンドラインも扱いやすいので人気があります。ハードはApple製のみで統一されているため不満も少なく、快適に動作します。&lt;/p&gt;

&lt;h3 id=&#34;壁紙&#34;&gt;壁紙&lt;/h3&gt;

&lt;p&gt;基本的にはターミナルを透過することもあり黒で設定する&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mba-hack/images/master/desktop/archlinux.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/mba-hack/images/master/desktop/screen.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;cli&#34;&gt;CLI&lt;/h2&gt;

&lt;p&gt;CLIは使ってるものが多すぎて整理中&lt;/p&gt;

&lt;h2 id=&#34;macos&#34;&gt;macOS&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Text&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.iterm2.com/downloads.html&#34;&gt;iTerm2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ターミナル&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://brew.sh/&#34;&gt;Homebrew&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;パッケージマネージャー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://pqrs.org/osx/karabiner/&#34;&gt;Karabiner&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;キーボード・カスタマイズ、ショートカット&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/fikovnik/ShiftIt/releases&#34;&gt;ShiftIt&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ショートカット&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://www.clipmenu.com/&#34;&gt;ClipMenu&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クリップボード&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://anime.syui.cf/macosx-nosleep-extension/&#34;&gt;NoSleep&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;スリープ抑止&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.virtualbox.org/wiki/Downloads&#34;&gt;VirtualBox&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;仮想環境&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://freemacsoft.net/appcleaner/&#34;&gt;AppCleaner&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;アプリ・アンインストーラー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.bresink.com/osx/TinkerTool.html&#34;&gt;TinkerTool&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;設定カスタマイズ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.piriform.com/ccleaner-mac&#34;&gt;CCleaner&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;クリーナー&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;karabiner&#34;&gt;Karabiner&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;~/Library/Application Support/Karabiner/private.xml&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
&amp;lt;root&amp;gt;

  &amp;lt;vkopenurldef&amp;gt;
    &amp;lt;name&amp;gt;KeyCode::VK_OPEN_URL_APP_MacVim&amp;lt;/name&amp;gt;
    &amp;lt;url type=&amp;quot;file&amp;quot;&amp;gt;/Applications/MacVim.app&amp;lt;/url&amp;gt;
  &amp;lt;/vkopenurldef&amp;gt;
  &amp;lt;vkopenurldef&amp;gt;
    &amp;lt;name&amp;gt;KeyCode::VK_OPEN_URL_APP_GoogleChrome&amp;lt;/name&amp;gt;
    &amp;lt;url type=&amp;quot;shell&amp;quot;&amp;gt;
	    &amp;lt;![CDATA[
	    open &amp;quot;/Applications/Google Chrome.app&amp;quot; --args --disable-javascript --disable-java --disable-plugins --incognito
	    ]]&amp;gt;
    &amp;lt;/url&amp;gt;
  &amp;lt;/vkopenurldef&amp;gt;
  &amp;lt;vkopenurldef&amp;gt;
    &amp;lt;name&amp;gt;KeyCode::VK_OPEN_URL_APP_GoogleChrome_Default&amp;lt;/name&amp;gt;
    &amp;lt;url type=&amp;quot;file&amp;quot;&amp;gt;/Applications/Google Chrome.app&amp;lt;/url&amp;gt;
  &amp;lt;/vkopenurldef&amp;gt;
  &amp;lt;vkopenurldef&amp;gt;
    &amp;lt;name&amp;gt;KeyCode::VK_OPEN_URL_APP_Terminal&amp;lt;/name&amp;gt;
    &amp;lt;url type=&amp;quot;file&amp;quot;&amp;gt;/Applications/iTerm.app&amp;lt;/url&amp;gt;
  &amp;lt;/vkopenurldef&amp;gt;
 &amp;lt;vkopenurldef&amp;gt;
    &amp;lt;name&amp;gt;KeyCode::VK_OPEN_URL_APP_FireFox&amp;lt;/name&amp;gt;
    &amp;lt;url type=&amp;quot;file&amp;quot;&amp;gt;/Applications/FireFox.app&amp;lt;/url&amp;gt;
  &amp;lt;/vkopenurldef&amp;gt;
 &amp;lt;vkopenurldef&amp;gt;
    &amp;lt;name&amp;gt;KeyCode::VK_OPEN_URL_APP_Safari&amp;lt;/name&amp;gt;
    &amp;lt;url type=&amp;quot;file&amp;quot;&amp;gt;/Applications/Safari.app&amp;lt;/url&amp;gt;
  &amp;lt;/vkopenurldef&amp;gt;
 &amp;lt;vkopenurldef&amp;gt;
    &amp;lt;name&amp;gt;KeyCode::VK_OPEN_URL_APP_Finder&amp;lt;/name&amp;gt;
    &amp;lt;url type=&amp;quot;file&amp;quot;&amp;gt;/System/Library/CoreServices/Finder.app&amp;lt;/url&amp;gt;
  &amp;lt;/vkopenurldef&amp;gt;

  &amp;lt;list&amp;gt;
    &amp;lt;item&amp;gt;
      &amp;lt;name&amp;gt;LeaveInsMode with EISUU(Terminal)&amp;lt;/name&amp;gt;
      &amp;lt;identifier&amp;gt;private.app_terminal_esc_with_eisuu&amp;lt;/identifier&amp;gt;
      &amp;lt;only&amp;gt;TERMINAL&amp;lt;/only&amp;gt;
      &amp;lt;autogen&amp;gt;--KeyToKey-- KeyCode::ESCAPE, KeyCode::ESCAPE, KeyCode::JIS_EISUU&amp;lt;/autogen&amp;gt;
      &amp;lt;autogen&amp;gt;--KeyToKey-- KeyCode::J, VK_CONTROL, KeyCode::J, VK_CONTROL, KeyCode::JIS_EISUU&amp;lt;/autogen&amp;gt;
      &amp;lt;autogen&amp;gt;--KeyToKey-- KeyCode::BRACKET_RIGHT, VK_CONTROL, KeyCode::BRACKET_RIGHT, VK_CONTROL, KeyCode::JIS_EISUU,KeyCode::BRACKET_RIGHT, VK_CONTROL, KeyCode::BRACKET_RIGHT, VK_CONTROL, KeyCode::JIS_EISUU&amp;lt;/autogen&amp;gt;
    &amp;lt;/item&amp;gt;

  &amp;lt;item&amp;gt;
    &amp;lt;name&amp;gt;Open MacVim&amp;lt;/name&amp;gt;
    &amp;lt;identifier&amp;gt;private.cmd_sh_v&amp;lt;/identifier&amp;gt;
    &amp;lt;autogen&amp;gt;
      __KeyToKey__
      KeyCode::V, ModifierFlag::SHIFT_L, ModifierFlag::COMMAND_L,
      KeyCode::VK_OPEN_URL_APP_MacVim
    &amp;lt;/autogen&amp;gt;
  &amp;lt;/item&amp;gt;

  &amp;lt;item&amp;gt;
    &amp;lt;name&amp;gt;Open Terminal&amp;lt;/name&amp;gt;
    &amp;lt;identifier&amp;gt;private.cmd_re&amp;lt;/identifier&amp;gt;
    &amp;lt;autogen&amp;gt;
      __KeyToKey__
      KeyCode::Z, ModifierFlag::COMMAND_L, ModifierFlag::SHIFT_L,
      KeyCode::VK_OPEN_URL_APP_Terminal
    &amp;lt;/autogen&amp;gt;
  &amp;lt;/item&amp;gt;

  &amp;lt;item&amp;gt;
    &amp;lt;name&amp;gt;Open Chrome&amp;lt;/name&amp;gt;
    &amp;lt;identifier&amp;gt;private.cmd_sh_g&amp;lt;/identifier&amp;gt;
    &amp;lt;autogen&amp;gt;
      __KeyToKey__
      KeyCode::G, ModifierFlag::COMMAND_L, ModifierFlag::SHIFT_L,
      KeyCode::VK_OPEN_URL_APP_GoogleChrome_Default
    &amp;lt;/autogen&amp;gt;
    &amp;lt;autogen&amp;gt;
      __KeyToKey__
      KeyCode::D, ModifierFlag::COMMAND_L, ModifierFlag::SHIFT_L,
      KeyCode::VK_OPEN_URL_APP_GoogleChrome
    &amp;lt;/autogen&amp;gt;
  &amp;lt;/item&amp;gt;

  &amp;lt;item&amp;gt;
    &amp;lt;name&amp;gt;Open FireFox&amp;lt;/name&amp;gt;
    &amp;lt;identifier&amp;gt;private.cmd_sh_f&amp;lt;/identifier&amp;gt;
    &amp;lt;autogen&amp;gt;
      __KeyToKey__
      KeyCode::F, ModifierFlag::COMMAND_L, ModifierFlag::SHIFT_L,
      KeyCode::VK_OPEN_URL_APP_FireFox
    &amp;lt;/autogen&amp;gt;
  &amp;lt;/item&amp;gt;

  &amp;lt;item&amp;gt;
    &amp;lt;name&amp;gt;Open Safari&amp;lt;/name&amp;gt;
    &amp;lt;identifier&amp;gt;private.cmd_sh_s&amp;lt;/identifier&amp;gt;
    &amp;lt;autogen&amp;gt;
      __KeyToKey__
      KeyCode::S, ModifierFlag::COMMAND_L, ModifierFlag::SHIFT_L,
      KeyCode::VK_OPEN_URL_APP_Safari
    &amp;lt;/autogen&amp;gt;
  &amp;lt;/item&amp;gt;

  &amp;lt;item&amp;gt;
    &amp;lt;name&amp;gt;Open Finder&amp;lt;/name&amp;gt;
    &amp;lt;identifier&amp;gt;private.cmd_1&amp;lt;/identifier&amp;gt;
    &amp;lt;autogen&amp;gt;
      __KeyToKey__
      KeyCode::KEY_1, ModifierFlag::COMMAND_L,
      KeyCode::VK_OPEN_URL_APP_Finder
    &amp;lt;/autogen&amp;gt;
  &amp;lt;/item&amp;gt;
  &amp;lt;/list&amp;gt;

&amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;起動音をoffにする&#34;&gt;起動音をOFFにする&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo nvram SystemAudioVolume=%00
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ディスクのマウント&#34;&gt;ディスクのマウント&lt;/h3&gt;

&lt;p&gt;MacではなぜかNTFSでフォーマットされたディスクの書き込みを許しません。したがって、以下のように読み書きができるようマウントできるようになります。&lt;/p&gt;

&lt;p&gt;ただし、書き込み後にディスク自体が壊れるという惨劇を発生させたので、おすすめしません、危険。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo mount -t ntfs -o rw,auto,nobrowse /dev/disk2s1 /mnt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;rootユーザーを有効にする&#34;&gt;rootユーザーを有効にする&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ dsenableroot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;あとは&lt;code&gt;command + shift + option + Q&lt;/code&gt;でログアウトして、rootでログイン後に&lt;code&gt;/etc/sudoers&lt;/code&gt;を編集したりもできます。&lt;/p&gt;

&lt;h3 id=&#34;復旧ディスクからターミナルでblessコマンドを実行する方法&#34;&gt;復旧ディスクからターミナルでblessコマンドを実行する方法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ diskutil list
disk0s1 200M EFI vfat
disk0s2 100G / ext4

$ cd /Volumes
$ mkdir efi
$ mount -t msdos /dev/disk0s1 /Volumes/efi

$ cp -r Image \Volume/System /Volumes/efi
$ cp /Volumes/efi/EFI/arch/grubx64.efi /Volumes/efi/System/Library/CoreServices/boot.efi
$ bless --folder=/Volumes/efi --file=/Volumes/efi/System/Library/CoreServices/boot.efi --setBoot

$ reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ブートメニューにアイコンを設定する方法&#34;&gt;ブートメニューにアイコンを設定する方法&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;/.volumeicon.icns&lt;/code&gt;を置くとできます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#Macのディスクにアイコンを設定する
$ sudo cp 設定したいファイル /.volumeicon.icns

#復旧ディスクにアイコンを設定する
$ diskutil list
$ mkdir mnt
$ sudo mount -t hfs /dev/disk0s3 ./mnt
$ sudo cp 設定したいファイル ./mnt/.volumeicon.icns
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;年式を調べる&#34;&gt;年式を調べる&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ system_profiler -listdatatypes | peco | xargs system_profiler -detailLevel full -xml
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bluetoohの音質を良くする&#34;&gt;Bluetoohの音質を良くする&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# apt-Xを有効にする
$ defaults write com.apple.BluetoothAudioAgent &amp;quot;Enable AptX codec&amp;quot; -bool true

# 確認
$ defaults read com.apple.BluetoothAudioAgent

# 設定の削除
$ defaults delete com.apple.BluetoothAudioAgent &amp;quot;Enable AptX codec&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;crontab相当をmacで使う&#34;&gt;crontab相当をMacで使う&lt;/h3&gt;

&lt;p&gt;Macの場合は面倒ですが、以下のスケジュール機能の&lt;code&gt;launchctl&lt;/code&gt;を使います。まず、設定ファイルを作成します。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;~/Library/LaunchAgents/foo.plist&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;quot;-//Apple//DTD PLIST 1.0//EN&amp;quot; &amp;quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;quot;&amp;gt;
&amp;lt;plist version=&amp;quot;1.0&amp;quot;&amp;gt;
    &amp;lt;dict&amp;gt;
        &amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;
        &amp;lt;string&amp;gt;foo&amp;lt;/string&amp;gt;
        &amp;lt;key&amp;gt;ProgramArguments&amp;lt;/key&amp;gt;
        &amp;lt;array&amp;gt;
            &amp;lt;string&amp;gt;/usr/local/bin/zsh&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;/Users/syui/bin/foo.sh&amp;lt;/string&amp;gt;
        &amp;lt;/array&amp;gt;
        &amp;lt;key&amp;gt;StartInterval&amp;lt;/key&amp;gt;
        &amp;lt;integer&amp;gt;60&amp;lt;/integer&amp;gt;
        &amp;lt;key&amp;gt;RunAtLoad&amp;lt;/key&amp;gt;
        &amp;lt;true/&amp;gt;
    &amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;StartInterval&lt;/code&gt;は秒を指定で&lt;code&gt;RunAtLoad&lt;/code&gt;は自動起動の設定です。次に、スケジュールをロードします。オプションは、&lt;code&gt;start, stop, unload&lt;/code&gt;など。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ launchctl load ~/Library/LaunchAgents/foo.plist
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;arch-linux&#34;&gt;Arch Linux&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Text&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://i3wm.org/&#34;&gt;i3&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ウィンドウマネージャー(WM)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/Tetralet/LilyTerm&#34;&gt;lilyterm&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;ターミナル&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;windows10&#34;&gt;Windows10&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Text&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://chocolatey.org&#34;&gt;Choco&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;パッケージマネージャー&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/PowerShell&#34;&gt;PowerShell&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コマンドシェル&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://msys2.github.io/&#34;&gt;MSYS2&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Linuxターミナル・システム&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cygwin.com/&#34;&gt;Cygwin&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Linuxターミナル・システム&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://www.mingw.org/&#34;&gt;MinGW&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コマンドパッケージ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://boxstarter.org/&#34;&gt;BoxStarter&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コマンドパッケージ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/pclouds/busybox-w32&#34;&gt;Busybox&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;コマンドパッケージ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://technet.microsoft.com/ja-jp/sysinternals/bb545027.aspx&#34;&gt;Sysinternals&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;システム管理&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.microsoft.com/ja-jp/dev/products/visual-studio-2015.aspx&#34;&gt;VirtualStudio&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;IEDエディタ&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/PowerShell/Win32-OpenSSH&#34;&gt;OpenSSH&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;リモート&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;パスワード-ログインの無効化&#34;&gt;パスワード・ログインの無効化&lt;/h3&gt;

&lt;p&gt;Windows10でパスワードを設定してると、起動時にパスワード入力を求められるのですが、これを自動入力する方法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;C+r -&amp;gt; netplwiz&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;cmdの文字化け&#34;&gt;cmdの文字化け&lt;/h3&gt;

&lt;p&gt;リモートで文字化けする場合は&lt;code&gt;chcp 65001&lt;/code&gt;に変更します。&lt;/p&gt;

&lt;p&gt;ターミナルの文字化けは&lt;code&gt;cmd&lt;/code&gt;のフォントも変更することで解決できるかもしれません。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Arch Linux</title>
      <link>https://anime.syui.cf/2016-10-02-archlinux</link>
      <pubDate>Sun, 02 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://anime.syui.cf/2016-10-02-archlinux</guid>
      <description>&lt;p&gt;Arch Linux のインストールから、Arch Linux を普段使っていく上で役立つ Tips を紹介します。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;p&gt;私が Linux を本格的に使い始めたのは Manjaro Linux からでした。&lt;/p&gt;

&lt;p&gt;Manjaro Linux というのは、Arch Linux をベースに GUI デスクトップを追加した Linux ディストリビューションです。インストールのしやすさとパッケージマネージャーの使いやすらから定評があります。また、Arch Linux ベースの OS はローリングリリースを採用しており、アップデートが早いことが特徴的です。&lt;/p&gt;

&lt;h3 id=&#34;方針について&#34;&gt;方針について&lt;/h3&gt;

&lt;p&gt;当記事の方針の一つは、著者が後々利用しやすいように作っていく方針です。&lt;/p&gt;

&lt;p&gt;一部、表現等に正確ではないものも含まれると思いますが、この記事では正確さよりも分かりやすさを重視します。もし正確な情報が欲しければ、&lt;a href=&#34;https://archlinuxjp.org/wiki&#34;&gt;ArchWiki&lt;/a&gt;など参照してください。&lt;/p&gt;

&lt;p&gt;なお、内容が充実してきたら別ページにも保存するかもしれません。&lt;/p&gt;

&lt;h3 id=&#34;著者のレベル&#34;&gt;著者のレベル&lt;/h3&gt;

&lt;p&gt;著者はコンピュータやLinuxについては全くの初心者です。一緒に勉強していきましょう。&lt;/p&gt;

&lt;h3 id=&#34;linux-など&#34;&gt;Linux など&lt;/h3&gt;

&lt;p&gt;いきなり専門用語を連発してしまいましたが、分からない人用に簡潔ではありますが、それぞれの単語のイメージするところを紹介します。&lt;/p&gt;

&lt;p&gt;Linux とは Linux カーネル(kernel) を意味したり、WindowsやMacのような一般的な OS とは異なる OSS(オープンソース・ソフトウェア) の無料 OS を意味したり、Linux ディストリビューションという Linux カーネルを使って開発されている様々な種類の Linux OS を意味したりします。&lt;/p&gt;

&lt;p&gt;ここで、カーネルというのはアプリとハードをつなぐ役割を担っている OS を動かすための必須の仕組み、機能をイメージすると分かりやすいです。&lt;/p&gt;

&lt;p&gt;ローリングリリースとは、常にアップデートされる仕組みのことです。&lt;/p&gt;

&lt;p&gt;パッケージマネージャーとは、アプリを管理するためのアプリのことで、インストールしたり、削除したりすることを簡単にしてくれます。&lt;/p&gt;

&lt;h3 id=&#34;arch-linux-の特徴&#34;&gt;Arch Linux の特徴&lt;/h3&gt;

&lt;p&gt;Arch Linux も Linux ディストリビューションの一つで、その特徴の一つはシンプルにあります。&lt;/p&gt;

&lt;p&gt;シンプル故に、何をするにしても自分でやらなければなりません。特に、環境の構築はユーザーに任されています。&lt;/p&gt;

&lt;p&gt;Arch Linux 自体は、パッケージマネージャーである&lt;code&gt;pacman&lt;/code&gt;及び、Arch Linuxのベース・パッケージである&lt;code&gt;base&lt;/code&gt;, &lt;code&gt;base-devel&lt;/code&gt;でできています。&lt;/p&gt;

&lt;h3 id=&#34;arch-linux-と似た-gentoo-linux&#34;&gt;Arch Linux と似た Gentoo Linux&lt;/h3&gt;

&lt;p&gt;ここで、Arch Linux はよく Gentoo Linux と比較されます。&lt;/p&gt;

&lt;p&gt;ここで、Gentoo Linux は Chrome OS Linux のベースにもなっているハッカークラスのユーザーに人気の OS です。&lt;/p&gt;

&lt;p&gt;Gentoo Linux は ローリング・リリースを採用している点及び、シンプルさ、つまり、環境構築は全てユーザーが行う点では Arch Linux に似ています。&lt;/p&gt;

&lt;p&gt;違いと言えば、Gentoo Linux のほうが対応アーキテクチャが多いことと、基本パッケージのビルドを自分のマシンで行うかどうかです。&lt;/p&gt;

&lt;p&gt;Arch Linux は基本パッケージを既にビルドされた状態でダウンロードし、インストールします。その為、Gentoo Linux に比べてインストール時間が非常に短いです。&lt;/p&gt;

&lt;p&gt;ただし、これは、どちらの OS もやろうと思えばできることです。例えば、Arch Linux もパッケージを独自ビルドすることは可能です。また、Gentoo Linux も GRP(Gentoo Reference Platform) という仕組みを使ってあらかじめビルド(コンパイル)されたパッケージを用いて、インストールを素早く行うことができます。&lt;/p&gt;

&lt;p&gt;私は、どちらかと言うと Arch Linux のほうが便利だと思ってこっちを使っています。それは、性能の低いマシンなどにもインストールすることがあり、その場合、ビルド時間が非常に長くなってしまう Gentoo Linux は基本的には向いていないと考えるからです。USB や Android などにもインストールして使います。&lt;/p&gt;

&lt;p&gt;ただし、Arch Linux が動かないマシンには、対応アーキテクチャの関係で Gentoo Linux を選択するだろうと思います。&lt;/p&gt;

&lt;h3 id=&#34;arch-linux-を選択するのに向いているユーザー&#34;&gt;Arch Linux を選択するのに向いているユーザー&lt;/h3&gt;

&lt;p&gt;基本的には、Arch Linux を使ってみたいという方なら、誰でも向いているというのが個人的な考えです。&lt;/p&gt;

&lt;p&gt;ただし、幾つかのアドバイスが必要だと思うので、それについて説明します。&lt;/p&gt;

&lt;p&gt;まず、環境構築に興味がない人には向いていないだろうと思います。&lt;/p&gt;

&lt;p&gt;なぜなら、Arch Linux はボタンを押したらインストールできるというものではないからです。&lt;/p&gt;

&lt;p&gt;自分でコマンドを叩き、欲しいパッケージを選んでインストールしないと起動しません。その際に叩くコマンドも、基本的なものではあるものの非常に多いです。特にデスクトップをある程度使えるくらいまでにしようと思ったら、叩くコマンドは多くなります。したがって、構築する環境によっては非常に時間と手間がかかります。&lt;/p&gt;

&lt;p&gt;次に、CL(コマンドライン) を日頃から使っていない人には Arch Linux は向いていないかもしれません。&lt;/p&gt;

&lt;p&gt;CLI を日頃から使っているユーザーは迷うことがないし、もしハマることがあったとしても、大抵は自力で問題を解決できると思われます。しかし、そうでないユーザーは、ハマったら抜けられないかもしれませんし、訳がわからないということになるかもしれません。この場合はやはり時間が勿体無いと思われます。また、トラウマになってしまうこともあるかもしれません。&lt;/p&gt;

&lt;h2 id=&#34;arch-linux-インストール関連&#34;&gt;Arch Linux インストール関連&lt;/h2&gt;

&lt;p&gt;基本的には、&lt;a href=&#34;https://wiki.archlinuxjp.org/index.php/%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%82%AC%E3%82%A4%E3%83%89&#34;&gt;インストールガイド&lt;/a&gt;を読めばOKです。&lt;/p&gt;

&lt;h3 id=&#34;インストールディスクのダウンロードと作成&#34;&gt;インストールディスクのダウンロードと作成&lt;/h3&gt;

&lt;p&gt;まずはArch Linuxのインストールディスクを作成します。インストールディスクと本体は全くの別物です。例えば、インストールディスクでのデフォルトシェルは&lt;code&gt;/bin/zsh&lt;/code&gt;ですが、本体は&lt;code&gt;bin/bash&lt;/code&gt;です。その他に様々な違いがあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# download iso
$ export url=http://ftp.jaist.ac.jp/pub/Linux/ArchLinux/iso/latest
$ export file=`curl -sL ${url} | grep &#39;.iso&amp;lt;&#39; | sed -n &#39;s/.*href=&amp;quot;\([^&amp;quot;]*\).*/\1/p&#39;`
$ export sum=${url}/md5sums.txt
$ export dl=${url}/${file}
$ export curl -sOL ${dl}

# check md5sum
$ curl -sLO ${sum}
$ md5sum -c md5sums.txt

# write usb
$ sudo dd bs=4M if=./${file} of=/dev/sdx &amp;amp;&amp;amp; sync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで、&lt;code&gt;md5sum&lt;/code&gt;はファイルが改ざんされていないかを調べるためのコマンドです。セキュリティ的には別々の場所に保存し、ファイルをダウンロードする都度チェックを行いますが、ファイルと同じ場所にハッシュ値が置かれることもあります。&lt;/p&gt;

&lt;h3 id=&#34;シェルスクリプト&#34;&gt;シェルスクリプト&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export b=b
$ export h=host
$ export u=user
$ export a=&amp;quot;jq net-tools git zsh tmux go ctags&amp;quot;

$ cp -rf /etc/pacman.d/mirrorlist /etc
$ zsh -c &amp;quot;cat /etc/mirrorlist | grep -A1 Japan &amp;gt;! /etc/pacman.d/mirrorlist&amp;quot;
$ sed -i &#39;s/--//g&#39; /etc/pacman.d/mirrorlist
$ pacman-key --refresh-keys
$ pacman -Sy
$ fdisk -l
$ parted /dev/sd${b} \
	-s mklabel gpt \ 
	-s mkpart primary ext2 0 200 \
	-s mkpart primary ext4 200 100% \
	-s p
$ mkfs.vfat /dev/sd${b}1
$ mkfs.ext4 /dev/sd${b}2
$ mount /dev/sd${b}2 /mnt
$ pacstrap /mnt base base-devel grub dhcpcd efibootmgr
$ genfstab -p /mnt &amp;gt;&amp;gt; /mnt/etc/fstab

$ echo -e &#39;[archlinuxfr]\nSigLevel = Never\nServer = http://repo.archlinux.fr/$arch&#39; &amp;gt;&amp;gt; /mnt/etc/pacman.conf
$ echo -e &#39;Defaults env_keep += &amp;quot;HOME&amp;quot;\n%wheel ALL=(ALL) ALL&#39; &amp;gt;&amp;gt; /mnt/etc/sudoers
$ echo -e &#39;%wheel ALL=(ALL) NOPASSWD: /usr/bin/pacman -Syu --noconfirm, /usr/bin/yaourt -Syua --noconfirm, /usr/bin/reboot, /usr/bin/poweroff&#39; &amp;gt;&amp;gt; /mnt/etc/sudoers
$ echo $h &amp;gt; /mnt/etc/hostname
$ echo -e &#39;en_US.UTF-8 UTF-8\nja_JP.UTF-8 UTF-8&#39; &amp;gt;&amp;gt; /mnt/etc/locale.gen
$ echo &#39;LANG=ja_JP.UTF-8&#39; &amp;gt; /mnt/etc/locale.conf

$ arch-chroot /mnt /bin/bash -c &amp;quot;
	pacman-db-upgrade
	grub-install --force --recheck /dev/sd${b}
	grub-mkconfig -o /boot/grub/grub.cfg
	systemctl enable dhcpcd
	pacman -S archlinux-keyring --noconfirm;

	useradd -m -G wheel -s /bin/bash $u

	ln -sf /usr/share/zoneinfo/Asia/Tokyo /etc/localtime
	timedatectl set-timezone Asia/Tokyo
	timedatectl set-ntp true
	hwclock --systohc --utc
	hwclock --systohc
	echo root:root | chpasswd
	echo $u:root | chpasswd

	pacman -Sy yaourt --noconfirm
	update-ca-trust
	pacman -Sy $a --noconfirm
&amp;quot;

$ reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;コマンド解説&#34;&gt;コマンド解説&lt;/h3&gt;

&lt;p&gt;では、以下より詳細な解説を行います。なお、上記コマンドの一部の不要な部分を省略することがあるかもしれません。&lt;/p&gt;

&lt;p&gt;まずはポイントから。以下のコマンドを使用すると、Arch Linuxのインストールを自動化できます。手動でやる場合はこのようなワンライナーではなく&lt;code&gt;cfdisk&lt;/code&gt;や&lt;code&gt;arch-chroot&lt;/code&gt;を単体で使いますが、自動化スクリプトを作成する場合はこのようなワンライナーを使えます。ディスクはインストールするものを選択します。気をつけましょう。ここでは本体&lt;code&gt;sda&lt;/code&gt;ではなく&lt;code&gt;sdb&lt;/code&gt;にインストールしています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# ディスクパーティションを作成する
# fdisk, cfdisk
$ parted /dev/sdb \ # sdb
	-s mklabel gpt \ # gpt
	-s mkpart primary ext2 0 200 \ # 0M - 200M
	-s mkpart primary ext4 200 100% \ # 200M - 残り全部
	-s p

# chrootで実行するコマンドの記述
$ arch-chroot /mnt /bin/bash -c &amp;quot;
	pacman-db-upgrade
&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;kernelからの情報取得&#34;&gt;Kernelからの情報取得&lt;/h3&gt;

&lt;p&gt;Kernelから吐かれた情報を取得することができます。Kernelから吐かれる情報は&lt;code&gt;/sys/class&lt;/code&gt;などに置いてあります。基本的にハードに関する情報で、コマンドから取得するよりも遥かに効率的です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh
export DISPLAY=:0.0
export XAUTHORITY=/home/`whoami`/.Xauthority
export battery_level=`cat /sys/class/power_supply/BAT0/capacity`
export battery_status=`cat /sys/class/power_supply/BAT0/status`
echo -e &amp;quot;$battery_level\n$battery_status&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;arch-linux-アプリ関連&#34;&gt;Arch Linux アプリ関連&lt;/h2&gt;

&lt;p&gt;基本的には、&lt;a href=&#34;https://wiki.archlinuxjp.org/index.php/%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E4%B8%80%E8%A6%A7&#34;&gt;アプリ一覧&lt;/a&gt;が便利です。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Unix &amp; Linux シェルスクリプト</title>
      <link>https://anime.syui.cf/2016-09-27-shellscript</link>
      <pubDate>Tue, 27 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://anime.syui.cf/2016-09-27-shellscript</guid>
      <description>&lt;p&gt;この記事は筆者 syui による、UNIX &amp;amp; Linux コマンド・シェルスクリプトに関する Tips をまとめたものになります。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;著者の環境は MacBook Air をメインに、OS には Arch Linux 及び MacOS を使うことが多いです。補助的に Alpine Linux と Windows も使います。ただ、各環境で完全にテストしているわけではないので、コマンド・シェルスクリプトの実行結果が当記事の内容と異なる場合があります。&lt;/p&gt;

&lt;p&gt;また、現在メインで使用しているシェルは&lt;code&gt;zsh&lt;/code&gt;と&lt;code&gt;fish&lt;/code&gt;です。したがって、&lt;code&gt;bash&lt;/code&gt;にもできる限り通用するよう心がけていますが、内容にシェル互換がないことがあるかもしれません。&lt;/p&gt;

&lt;p&gt;最後に、著者はコンピュータについては全くの初心者です。多分、はじめてコンピュータを触ったばかりの人よりも遥かに劣るレベルだと思われます。その点は考慮していただけると幸いです。一緒にシェルスクリプトを学習していきましょう。&lt;/p&gt;

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;h3 id=&#34;シェルスクリプトについて&#34;&gt;シェルスクリプトについて&lt;/h3&gt;

&lt;p&gt;シェルスクリプトは解読に難はあるものの(ようは読みづらい)、何らかの仕組みを作る上では便利であり、簡単にできるものだと思っています。その理由の一つがシェルのシンプルな仕組みにあります。&lt;/p&gt;

&lt;p&gt;シェル・コマンドの仕組みは、物事をシンプル簡単に処理することにあります。具体的には、一つのコマンドを叩けば結果が出力される仕組みです。分かりやすいですよね。&lt;/p&gt;

&lt;p&gt;更に、それらをパイプを使って繋げることで、出力は変化していきます。これも特別難しいものではありません。&lt;/p&gt;

&lt;p&gt;この出力を自在に操ることでシェルスクリプトは作成されます。&lt;/p&gt;

&lt;p&gt;シェルスクリプトというのは、単純にコマンドの羅列に過ぎません。&lt;/p&gt;

&lt;p&gt;このような仕組みは非常に分かりやすく、かつ簡単に実行可能です。&lt;/p&gt;

&lt;p&gt;そして、やりたいことを実現できる能力も備わっています。&lt;/p&gt;

&lt;p&gt;それは、世の中には便利なコマンドがたくさんあるからです。&lt;/p&gt;

&lt;p&gt;これは最新技術にも言えることで、最新技術の多くはCLIコマンドを用意しています。&lt;/p&gt;

&lt;p&gt;また、プログラムやシステムの初期段階では、簡易化されたコマンドやシェルスクリプトを使用する傾向が少なからずあります。&lt;/p&gt;

&lt;p&gt;したがって、シェルスクリプトを学ぶ意味は現代においても十分にあると考えています。&lt;/p&gt;

&lt;p&gt;この記事では、筆者がシェルスクリプトを使用するにあたって便利だと思った内容を中心にシェルスクリプトについて書いていきたいと思います。&lt;/p&gt;

&lt;h3 id=&#34;方針について&#34;&gt;方針について&lt;/h3&gt;

&lt;p&gt;当記事の方針の一つは、著者が後々利用しやすいように作っていく方針です。&lt;/p&gt;

&lt;p&gt;一部、表現等に正確ではないものも含まれると思いますが、この記事では正確さよりも分かりやすさを重視します。もし正確な情報が欲しければ、公式や&lt;code&gt;$ man bash&lt;/code&gt;などを参照してください。&lt;/p&gt;

&lt;p&gt;なお、内容が充実してきたら別ページにも保存するかもしれません。&lt;/p&gt;

&lt;h2 id=&#34;シェルスクリプト入門&#34;&gt;シェルスクリプト入門&lt;/h2&gt;

&lt;h3 id=&#34;シェルスクリプトとは&#34;&gt;シェルスクリプトとは&lt;/h3&gt;

&lt;p&gt;シェルスクリプト(shell script)とは、基本的にはシェルを使って実行するコマンドの羅列です。これはテキストファイルに書き込みます。&lt;/p&gt;

&lt;p&gt;まずは、難解なプログラムのイメージではなく、単に各種コマンドをつなぎ合わせたものだと考えてください。このようにイメージすることで、プログラミングに馴染みがない人にも心理的抵抗は少なくなるはずです。&lt;/p&gt;

&lt;p&gt;コマンドの中には構文コマンドなども多数存在しており、わざわざテキストファイルから実行しなくても実行できます。以下は&lt;code&gt;for&lt;/code&gt;文を直接実行した例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ for i in *;do echo ${i%.*} &amp;amp;&amp;amp; pwd;done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、このようなワンライナー(1行に詰め込まれたコマンドのこと)を何度も直接実行するのは面倒で、かつ解読にも難があることから、テキストファイルに記述して実行することがあります。&lt;/p&gt;

&lt;p&gt;シェルスクリプトは主にこのような目的で作成される事が多いです。&lt;/p&gt;

&lt;p&gt;以下は上記をシェルスクリプト形式で記述した例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh
for i in *
do
	echo ${i%.*} \
	&amp;amp;&amp;amp; pwd
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こちらのほうが何をやっているのか分かりやすいですよね。&lt;/p&gt;

&lt;p&gt;また、当該コマンドを後々何度も実行することが予想される場合、コマンドではなく、シェルスクリプトとして保存しておいたほうが便利になります。何度も難解なコマンドを手動で入力するのは煩雑だからです。&lt;/p&gt;

&lt;h3 id=&#34;シェルとは&#34;&gt;シェルとは&lt;/h3&gt;

&lt;p&gt;シェルスクリプトがコマンドの羅列だとして、シェルとは何でしょう。&lt;/p&gt;

&lt;p&gt;ここで言うシェル(shell)とは、ユーザーが間接的にカーネルとの意思疎通を行うためのツールのことです。具体的には&lt;code&gt;bash&lt;/code&gt;や&lt;code&gt;zsh&lt;/code&gt;, &lt;code&gt;fish&lt;/code&gt;がシェルに該当します。このように、シェルにも様々な種類があり、ユーザーが主に好みによって使用するシェルを選択します。&lt;/p&gt;

&lt;p&gt;また、カーネル(kernel)とはOSの核で、主にハードとソフト(アプリ)の仲介を行います。&lt;/p&gt;

&lt;h3 id=&#34;ターミナルなど&#34;&gt;ターミナルなど&lt;/h3&gt;

&lt;p&gt;シェルを理解する上では、ターミナル(terminal)などの概念も重要になってきます。シェルを自在に操る人は、一般人から見ると真っ黒な画面で何やら怪しげなことをしているコンピューター・ハッカーにしか見えません。&lt;/p&gt;

&lt;p&gt;ここで、真っ黒な画面がターミナルと呼ばれるアプリになります。そして、このターミナルアプリで実行されているのがシェルです。&lt;/p&gt;

&lt;p&gt;シェルを通して処理されるものがコマンドということになります。&lt;/p&gt;

&lt;p&gt;このようにコマンド(文字列)でコンピュータを操作する操作画面のことをCLI(コマンドラインインターフェイス)と言います。&lt;/p&gt;

&lt;p&gt;ハッカー(hacker)が好んで使用するのインターフェイスもこのCLIであることが多いので、一般人の理解も完全に間違っているわけではありません。その認識は概ね正しいといえるでしょう。&lt;/p&gt;

&lt;p&gt;シェルを自在に操るには、コンピュータへの深い理解が必要になることが多いからです。&lt;/p&gt;

&lt;p&gt;そして、ここで言うハッカーとはコンピュータへの深い理解と知識を有した人のことを言います。決してコンピュータを使って悪事を働く人を意味するわけではありません。&lt;/p&gt;

&lt;p&gt;コマンドと言うものは、たった1つでも多くの処理をこなしてしまうため、一見して簡単ですが、危険な面もあるということを覚えておいてください。&lt;/p&gt;

&lt;p&gt;この点、システムやシェルへの理解がないと、間違ったコマンドを実行して大きな過ちを犯してしまう危険があります。&lt;/p&gt;

&lt;p&gt;そして、その範囲は、OSの核であるカーネルとやり取りするだけあって、あまりに膨大です。&lt;/p&gt;

&lt;p&gt;ただし、知っておくべき膨大な知識を前に、失敗するのを怖がっているだけでは何も始まりません。&lt;/p&gt;

&lt;p&gt;私の考えとしては、コマンドの危険性やそのための知識はとりあえず脇に置いておき、まずはコマンドを叩いてみる、そして、それを繋げてみることから始めましょう。&lt;/p&gt;

&lt;p&gt;確かに、失敗するかもしれません。いや、多分するでしょう。しかし、地雷を踏めば踏むほどシステムに詳しくなれると私は考えています。&lt;/p&gt;

&lt;p&gt;例えば、私は、Arch LinuxというOSを使っていますが、Arch Linuxには山ほど地雷があります。ただ、それを踏んだからこそ、少しはコンピュータ(ここではLinux)に詳しくなったのも事実だと感じています。&lt;/p&gt;

&lt;p&gt;さて、失敗を恐れず、いや、失敗を当然の前提として先に進むことにしましょう。&lt;/p&gt;

&lt;h3 id=&#34;manを読むタイミング&#34;&gt;manを読むタイミング&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;man&lt;/code&gt;というマニュアル(ドキュメント)コマンドがあります。ここで&lt;code&gt;man&lt;/code&gt;を読むタイミングについて少しばかり紹介します。&lt;/p&gt;

&lt;p&gt;あなたは、何かを始めようとした時、まず&lt;code&gt;man&lt;/code&gt;を実行することを考えますか?&lt;/p&gt;

&lt;p&gt;ほとんどの人は入門段階では、まずGoogle検索を行うと思います。&lt;/p&gt;

&lt;p&gt;そして、それは概ね正しい判断です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;man&lt;/code&gt;はつまらない事が多いし、&lt;code&gt;Example&lt;/code&gt;にも対応していないことが多いからです。&lt;/p&gt;

&lt;p&gt;このような理由から、私は&lt;code&gt;man&lt;/code&gt;を読むタイミングは入門を終えた後のほうが良いと考えています。&lt;/p&gt;

&lt;p&gt;CLIに慣れているユーザーは最初に&lt;code&gt;man&lt;/code&gt;を読む人も多いのですが、この記事の読者対象は、あくまで初学者であり、入門者です。&lt;/p&gt;

&lt;p&gt;したがって、いきなり&lt;code&gt;man&lt;/code&gt;を読むことはオススメしませんし、また、&lt;code&gt;man&lt;/code&gt;を読むことがすなわち崇高であることにも結びつきません。&lt;/p&gt;

&lt;p&gt;学び方は人それぞれですし、また、タイミングも人それぞれです。&lt;/p&gt;

&lt;p&gt;自分のレベルに合ったやり方を選択していきましょう。決して背伸びする必要はありませんし、見栄を張る必要もありません。&lt;/p&gt;

&lt;p&gt;ただし、&lt;code&gt;man&lt;/code&gt;は非常に役立つコマンドでもあります。面白くなってきたと感じたら読んでみることをオススメします。これは多くの熟練者達も皆同じだと思います。&lt;/p&gt;

&lt;h3 id=&#34;シェルの種類&#34;&gt;シェルの種類&lt;/h3&gt;

&lt;p&gt;シェルスクリプトを作成するにあたって、まず使用するシェルを決める必要があります。シェルには多くの種類があり、ハードやOSによって搭載されているものが異なります。それぞれに得意不得意があるからです。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;ash&lt;/code&gt;というシェルは&lt;code&gt;busybox&lt;/code&gt;というコマンドパッケージに入っており、小さなハードに組み込まれることが多いシェルです。それだけにミニマムですが、パワーに欠けるかもしれません。&lt;code&gt;bash&lt;/code&gt;や&lt;code&gt;zsh&lt;/code&gt;では直前に実行したコマンドなどを&lt;code&gt;!!&lt;/code&gt;から使えますが、&lt;code&gt;ash&lt;/code&gt;では使えなかった記憶があります。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ash&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo pacman -S busybox
$ busybox ash
$ echo {直前のコマンド}
$ echo !!
!!
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;bash&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo {直前のコマンド}
$ echo !!
echo {直前のコマンド}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arch Linuxの&lt;code&gt;base&lt;/code&gt;パッケージに&lt;code&gt;bash&lt;/code&gt;シェルが入っています。&lt;code&gt;bash&lt;/code&gt;はLinuxで最も普及しているシェルです。また、&lt;code&gt;sh&lt;/code&gt;というものもありますが、実際この中身が&lt;code&gt;bash&lt;/code&gt;に置き換えられることも多いです。&lt;/p&gt;

&lt;p&gt;私が好んで使用しているシェルは&lt;code&gt;zsh&lt;/code&gt;と言います。これはデフォルトのTab補完が便利であることからとても人気があります。Arch Linuxのインストールディスク(ブートディスク)にも採用されています(ただしbaseには入っていない)。&lt;/p&gt;

&lt;p&gt;なお、私は最近、&lt;code&gt;fish&lt;/code&gt;というシェルも使っています。&lt;code&gt;fish&lt;/code&gt;は補完の他、カラフルなインターフェイスと構文に力を入れているシェルです。&lt;code&gt;fish&lt;/code&gt;は他のシェルとの互換性を損なう場面も多いですが、構文の解読が分かりやすいというメリットがあります。&lt;/p&gt;

&lt;p&gt;ここで、当サイトでは主に&lt;code&gt;zsh&lt;/code&gt;を用いてシェルスクリプトを解説していきます。&lt;/p&gt;

&lt;p&gt;理由としては&lt;code&gt;zsh&lt;/code&gt;の使用者がそこそこいることと、パスの記述が&lt;code&gt;bash&lt;/code&gt;よりも分かりやすいからです。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;bash&lt;/code&gt;と&lt;code&gt;zsh&lt;/code&gt;で実行するシェルスクリプトから絶対パスを取得する記述は以下のようになります。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;bash&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
f=$0
d=$(cd $(dirname $0);pwd)
l=$(cd $(dirname $0);cd ..;pwd)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;zsh&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh
f=$0
d=${0:a:h}
l=${0:a:h:h}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、このような事情から以下のようなコマンドにも違いが出てきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo https://syui.gitlab.io/shellscript
$ echo !$:t
shellscript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好みの問題にもなりますが、私は&lt;code&gt;zsh&lt;/code&gt;のほうが好きですね。&lt;/p&gt;

&lt;h3 id=&#34;シェルスクリプトの作成&#34;&gt;シェルスクリプトの作成&lt;/h3&gt;

&lt;p&gt;シェルスクリプトの作成は、通常、シバンから記述します。&lt;/p&gt;

&lt;p&gt;シバン(shebang)というのは、シェルに当該テキストを読み込む実行コマンドを教えるために記述するもので、一般的には&lt;code&gt;#!/path/to/foo&lt;/code&gt;という形で実行ファイルの絶対パスを記述します。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;zsh&lt;/code&gt;でシェルスクリプトを作成したければ、&lt;code&gt;#!/bin/zsh&lt;/code&gt;のように記述します。コマンドの絶対パスは&lt;code&gt;which&lt;/code&gt;コマンドなどから調べることが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ which zsh
/bin/zsh
or
$ type zsh
zsh is /bin/zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、&lt;code&gt;env&lt;/code&gt;コマンドがあり、これはシバンにするパスを置き換える事ができます。つまり、&lt;code&gt;#!/bin/env zsh&lt;/code&gt;のような記述ができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ which env
/bin/env

&amp;gt; #!/bin/env zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;env&lt;/code&gt;を使用するメリットはシェルのインストール先が環境ごとに異なる場合です。例えば、&lt;code&gt;zsh&lt;/code&gt;が&lt;code&gt;/bin/zsh&lt;/code&gt;と&lt;code&gt;/usr/bin/zsh&lt;/code&gt;にインストールされている環境があったとして、&lt;code&gt;env&lt;/code&gt;で記述することでどちらの環境でも動作します。&lt;/p&gt;

&lt;p&gt;ただし、&lt;code&gt;env&lt;/code&gt;はインタプリタにコマンドライン引数としてオプションを渡すことができないなどのデメリットがあり、特別な事情がない限り&lt;code&gt;env&lt;/code&gt;の使用は推奨しません。&lt;/p&gt;

&lt;p&gt;シバンの後は、コマンドを記述すればシェルスクリプトの完成です。ここでは&lt;code&gt;t.sh&lt;/code&gt;という名前で保存します。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;t.sh&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
echo &amp;quot;hello world!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;後は実行権限を渡し、&lt;code&gt;t.sh&lt;/code&gt;ファイルを実行します。ファイル権限については後述しますが、&lt;code&gt;x&lt;/code&gt;は実行権限を意味します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ chmod +x t.sh
$ ./t.sh
hello world!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他にもシェルスクリプトの実行には様々な方法があります。また、&lt;code&gt;zsh -c&lt;/code&gt;などで実行するコマンドは設定ファイルが使われないので、シェルスクリプトを書く際に便利なことがあります。シェルスクリプトを書く時、&lt;code&gt;source&lt;/code&gt;などで環境変数などを読み込むことがあり、それによってコマンドの挙動が変化することがあるので、その回避策として使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bash t.sh
$ zsh -c ./t.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;シェルを指定して実行した場合、ファイル自体は指定したシェルが使われますが、テキストの中身はシバンで指定したシェルが使われます。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;t.sh&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh
echo $SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;試しに上記を&lt;code&gt;bash&lt;/code&gt;で実行してみましょう。結果はシェルスクリプト内に書いたコマンドを実行しているシェルになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bash t.sh 
/bin/zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ファイルのパーミッション&#34;&gt;ファイルのパーミッション&lt;/h3&gt;

&lt;p&gt;ファイルのパーミッション(権限)には以下の様なものが一般的です。ディレクトリも厳密にはファイルの一種なのでパーミッションがあります。基本的には&lt;code&gt;x=実行&lt;/code&gt;, &lt;code&gt;r=読み込み&lt;/code&gt;, &lt;code&gt;w=書き込み&lt;/code&gt;を意味します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# タイムスタンプの書き換え
$ touch -t 000001010000 *

# パーミッションの確認
$ ls -l
4.0K -rwxr-xr-x 1 syui staff  35  1  1  0000 t.sh

# パーミッションの付与(すべてのユーザーはa+)
$ chmod a+rwx t.sh
4.0K -rwxrwxrwx 1 syui staff  35  1  1  0000 t.sh

# パーミッションの削除
$ chmod a-rwx t.sh
4.0K ---------- 1 syui staff  35  1  1  0000 t.sh

# 実行権限のみ付与
$ chmod +x t.sh
4.0K ---x--x--x 1 syui staff  35  1  1  0000 t.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで&lt;code&gt;chmod&lt;/code&gt;コマンドは&lt;code&gt;a+&lt;/code&gt;がすべてのユーザーを対象にします。&lt;code&gt;u+&lt;/code&gt;がユーザーで&lt;code&gt;g+&lt;/code&gt;がグループ, &lt;code&gt;o+&lt;/code&gt;がその他です。指定しないとユーザー&lt;code&gt;u+&lt;/code&gt;になります。&lt;/p&gt;

&lt;p&gt;ディレクトリのパーミッションを変更したければ、以下のように&lt;code&gt;-R&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ chmod -R +x .
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;パスについて&#34;&gt;パスについて&lt;/h3&gt;

&lt;p&gt;基本的なパスの概念は絶対パスと相対パスがあります。絶対パスはルートディレクトリから数えたパスで、相対パスは現在地から数えたパスです。&lt;/p&gt;

&lt;p&gt;以下、具体例を示します。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;現在場所 : &lt;code&gt;~/git/shell/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;絶対パス : &lt;code&gt;$ /home/syui/git/shell/t.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;相対パス : &lt;code&gt;$ ./t.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;そして、パスを通すという言葉があります。この言葉は環境変数である&lt;code&gt;PATH&lt;/code&gt;にパスを追加する事を意味します。パスを通すと、そのディレクトリ内にあるファイルはパスの記述なしに実行できるようになります。&lt;/p&gt;

&lt;p&gt;本当にパスの記述が不要になるか各々試してみましょう。ここでは&lt;code&gt;t.sh&lt;/code&gt;がある&lt;code&gt;~/git/shell&lt;/code&gt;をPATHに追加することにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pwd
/home/syui/git/shell

$ echo $PATH
/bin:/usr/bin

$ export PATH=$PATH:`pwd`

$ echo $PATH
/bin:/usr/bin:/home/syui/git/shell

$ cd

$ pwd
/home/syui

$ t.sh
hello world!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;様々な記述&#34;&gt;様々な記述&lt;/h3&gt;

&lt;p&gt;上記ではホームディレクトリを&lt;code&gt;~&lt;/code&gt;と&lt;code&gt;/home/syui&lt;/code&gt;で表しています。このように、ホームディレクトリは&lt;code&gt;~&lt;/code&gt;に省略できます。他にも様々な省略記法がシェルには用意されています。これはシェルによって変わってきますが、基本的なものは大体同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo ~
/home/syui

$ echo ^
t.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;変数&#34;&gt;変数&lt;/h3&gt;

&lt;p&gt;シェルには最初から定義されている変数が幾つかあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 現在使用しているシェルを調べる
$ echo $SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで、変数の使い方は代入及び出力で理解できると思います。使用した文字列の先頭に&lt;code&gt;$&lt;/code&gt;を付けると変数を使えます。また、他の文字列と連結することによって違う意味になることがあるので、確実な変数の使用のためには&lt;code&gt;${x}&lt;/code&gt;というように括弧でくくるとより確実です。この辺はケースバイケースで考えましょう。必ずしも括弧に入れる必要はありません。なお、&lt;code&gt;export&lt;/code&gt;コマンドは省略できます。ただし、&lt;code&gt;export&lt;/code&gt;コマンドで代入することでグローバル変数にすることができ、環境が変わっても参照できるようになります。より確実に参照したい場合は&lt;code&gt;export&lt;/code&gt;で代入するのが良いかもしれません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 代入
$ export a=foo
or
$ a=foo

# 出力
$ echo $a
foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで、代入というのは中身を書き換えるようなイメージです。例えば、&lt;code&gt;a&lt;/code&gt;に&lt;code&gt;test&lt;/code&gt;を代入する場合、&lt;code&gt;$ a=test&lt;/code&gt;というコマンドを実行することになります。実行すると変数&lt;code&gt;a&lt;/code&gt;の中身は&lt;code&gt;test&lt;/code&gt;に変わります。変数というのは、このように中身を自在に書き換えて使うことが出来ます。何が便利なのかというと、何度も利用する事ができる点です。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;test&lt;/code&gt;という文字列を10回出力したいとします。この場合、わざわざ&lt;code&gt;test&lt;/code&gt;を10回書くよりも変数に入れて使用した方が効率が良くなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh
a=test
for ((i=1;i&amp;lt;=10;i++))
do
	echo $a
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、以下のように指定回数コマンドを実行することもできます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export a=test
$ zsh -c &amp;quot;repeat 10 echo $a&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;改行を含めた変数&#34;&gt;改行を含めた変数&lt;/h4&gt;

&lt;p&gt;ここはシェルスクリプトのマハリどころなのですが、変数には改行を含めることができます。&lt;/p&gt;

&lt;p&gt;ただし、それを参照する場合は、ダブルクオーテーションで囲まなければならないことがあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo -e &amp;quot;test\nshell&amp;quot;
test
shell

$ a=!$

$ echo $a
testshell

$ echo &amp;quot;$a&amp;quot;
test
shell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん、ダブルクオーテーションで囲まなくても改行が含まれる場合もあり、この辺はどのような理由で含まれなかったり、含まれたりするのかよく分かりません。よって、確実に改行を含めたい場面では、ダブルクオーテーションを使うようにしています。&lt;/p&gt;

&lt;h3 id=&#34;文字列比較など&#34;&gt;文字列比較など&lt;/h3&gt;

&lt;p&gt;文字列比較や変数が空かどうか調べるにもダブルクオーテーションが必要になることがあります。以下は引数があればそれを出力する内容になっています。もし引数がなければ&lt;code&gt;error&lt;/code&gt;を表示します。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;t.sh&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh
if [ -n &amp;quot;$1&amp;quot; ];then
	echo $1
else
	echo error
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./t.sh 
error

$ ./t.sh good!
good!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;シングルクォーテーションとダブルクオーテーション&#34;&gt;シングルクォーテーションとダブルクオーテーション&lt;/h3&gt;

&lt;p&gt;ダブルクオーテーション&lt;code&gt;&amp;quot;&lt;/code&gt;とシングルクォーテーション&lt;code&gt;&#39;&lt;/code&gt;の使い分けについてです。&lt;/p&gt;

&lt;p&gt;基本的にはダブルは変数を使うことが出来ますが、シングルは変数が使えません(書き方にもよりますが)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ a=test

$ echo &#39;$a&#39;
$a

$ echo &amp;quot;$a&amp;quot;
test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、ダブルの中でダブルを使いたい場合などは手前に&lt;code&gt;\&lt;/code&gt;を記述することで解決できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo &amp;quot;\&amp;quot;$a\&amp;quot;&amp;quot;
&amp;quot;test&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;私は、そのままの文字列を使いたい場合、シングルを使うようにしています。それ以外ではダブルを使うことが多いです。&lt;/p&gt;

&lt;p&gt;ちなみに、このようなテクニックは変数に代入するときにも使えます。&lt;/p&gt;

&lt;h3 id=&#34;シェルスクリプトの文法&#34;&gt;シェルスクリプトの文法&lt;/h3&gt;

&lt;p&gt;シェルスクリプトの文法は他のスクリプト言語に比べて非常に簡素で、かつ馴染みにくいものかもしれません。&lt;/p&gt;

&lt;p&gt;ただ、一つのコマンドとして捉えると分かりやすく、そして、納得できるものでもあります。&lt;/p&gt;

&lt;p&gt;言語的には推測が難しい側面がありますが、コマンドやコマンドオプション的には推測が可能です。&lt;/p&gt;

&lt;p&gt;そのあたりを意識して、シェルスクリプトで使われる一般的な文法表現について見ていくことにします。&lt;/p&gt;

&lt;h4 id=&#34;if-文の使用例&#34;&gt;if 文の使用例&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh

# コメント
a=0
if [ $a -eq 0 ];then
	echo &amp;quot;ok.&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;計算や比較の条件式には&lt;code&gt;[]&lt;/code&gt;を使います。注意点としてスペースが必要になります。これらも一つのコマンドです。&lt;code&gt;-eq&lt;/code&gt;は同じ数値であるか比較するオプションです。&lt;/p&gt;

&lt;p&gt;ここで、&lt;code&gt;;&lt;/code&gt;の意味はコマンドの終わりや改行を意味します。&lt;code&gt;then&lt;/code&gt;は条件の終わりを意味します。つまり、以下のように書いても同じ内容になります。ちなみに、&lt;code&gt;fi&lt;/code&gt;は&lt;code&gt;if&lt;/code&gt;文の終わりですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh

a=0
if [ $a -eq 0 ]
then
	echo &amp;quot;ok.&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、単純に条件処理をしたい場合は、括弧を使わず&lt;code&gt;if&lt;/code&gt;のみで判定することもできます。&lt;/p&gt;

&lt;p&gt;例えば、コマンドが成功した場合の処理は以下のようになります。つまり、条件に&lt;code&gt;if ~&lt;/code&gt;以降に記述されるコマンドの成否を設定しているわけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh

if echo 0 | grep 0;then
	echo &amp;quot;$?&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、条件の追加&lt;code&gt;elif&lt;/code&gt;や条件に当てはまらない場合の処理&lt;code&gt;else&lt;/code&gt;を書くことができます。注意点として、文字列比較は必ずダブルでもシングルでも良いので、クォーテーションを付けなければなりません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh

str=test
if [ &amp;quot;$str&amp;quot; = &amp;quot;foo&amp;quot; ];then
  echo &amp;quot;foo&amp;quot;
elif [ &amp;quot;$str&amp;quot; = &amp;quot;bar&amp;quot; ];then
  echo &amp;quot;bar&amp;quot;
else
  echo &amp;quot;unset&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;条件を反転させる場合は、大抵、&lt;code&gt;!&lt;/code&gt;を付けることで解決できます。この例では、&lt;code&gt;a&lt;/code&gt;でない時に条件が満たされます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;if [ &amp;quot;a&amp;quot; != &amp;quot;b&amp;quot; ];then
	:
fi
if !echo a|grep b;then
	:
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;test&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>