<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Zsh on アニメ海外反応</title>
    <link>https://anime.syui.cf/tags/zsh/index.xml</link>
    <description>Recent content in Zsh on アニメ海外反応</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <copyright>Powered by [Hugo](//gohugo.io). Theme by [term](https://gitlab.com/syui/hugo-theme-term).</copyright>
    <atom:link href="https://anime.syui.cf/tags/zsh/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Unix &amp; Linux シェルスクリプト</title>
      <link>https://anime.syui.cf/2016-09-27-shellscript</link>
      <pubDate>Tue, 27 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>https://anime.syui.cf/2016-09-27-shellscript</guid>
      <description>&lt;p&gt;この記事は筆者 syui による、UNIX &amp;amp; Linux コマンド・シェルスクリプトに関する Tips をまとめたものになります。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;著者の環境は MacBook Air をメインに、OS には Arch Linux 及び MacOS を使うことが多いです。補助的に Alpine Linux と Windows も使います。ただ、各環境で完全にテストしているわけではないので、コマンド・シェルスクリプトの実行結果が当記事の内容と異なる場合があります。&lt;/p&gt;

&lt;p&gt;また、現在メインで使用しているシェルは&lt;code&gt;zsh&lt;/code&gt;と&lt;code&gt;fish&lt;/code&gt;です。したがって、&lt;code&gt;bash&lt;/code&gt;にもできる限り通用するよう心がけていますが、内容にシェル互換がないことがあるかもしれません。&lt;/p&gt;

&lt;p&gt;最後に、著者はコンピュータについては全くの初心者です。多分、はじめてコンピュータを触ったばかりの人よりも遥かに劣るレベルだと思われます。その点は考慮していただけると幸いです。一緒にシェルスクリプトを学習していきましょう。&lt;/p&gt;

&lt;h2 id=&#34;はじめに&#34;&gt;はじめに&lt;/h2&gt;

&lt;h3 id=&#34;シェルスクリプトについて&#34;&gt;シェルスクリプトについて&lt;/h3&gt;

&lt;p&gt;シェルスクリプトは解読に難はあるものの(ようは読みづらい)、何らかの仕組みを作る上では便利であり、簡単にできるものだと思っています。その理由の一つがシェルのシンプルな仕組みにあります。&lt;/p&gt;

&lt;p&gt;シェル・コマンドの仕組みは、物事をシンプル簡単に処理することにあります。具体的には、一つのコマンドを叩けば結果が出力される仕組みです。分かりやすいですよね。&lt;/p&gt;

&lt;p&gt;更に、それらをパイプを使って繋げることで、出力は変化していきます。これも特別難しいものではありません。&lt;/p&gt;

&lt;p&gt;この出力を自在に操ることでシェルスクリプトは作成されます。&lt;/p&gt;

&lt;p&gt;シェルスクリプトというのは、単純にコマンドの羅列に過ぎません。&lt;/p&gt;

&lt;p&gt;このような仕組みは非常に分かりやすく、かつ簡単に実行可能です。&lt;/p&gt;

&lt;p&gt;そして、やりたいことを実現できる能力も備わっています。&lt;/p&gt;

&lt;p&gt;それは、世の中には便利なコマンドがたくさんあるからです。&lt;/p&gt;

&lt;p&gt;これは最新技術にも言えることで、最新技術の多くはCLIコマンドを用意しています。&lt;/p&gt;

&lt;p&gt;また、プログラムやシステムの初期段階では、簡易化されたコマンドやシェルスクリプトを使用する傾向が少なからずあります。&lt;/p&gt;

&lt;p&gt;したがって、シェルスクリプトを学ぶ意味は現代においても十分にあると考えています。&lt;/p&gt;

&lt;p&gt;この記事では、筆者がシェルスクリプトを使用するにあたって便利だと思った内容を中心にシェルスクリプトについて書いていきたいと思います。&lt;/p&gt;

&lt;h3 id=&#34;方針について&#34;&gt;方針について&lt;/h3&gt;

&lt;p&gt;当記事の方針の一つは、著者が後々利用しやすいように作っていく方針です。&lt;/p&gt;

&lt;p&gt;一部、表現等に正確ではないものも含まれると思いますが、この記事では正確さよりも分かりやすさを重視します。もし正確な情報が欲しければ、公式や&lt;code&gt;$ man bash&lt;/code&gt;などを参照してください。&lt;/p&gt;

&lt;p&gt;なお、内容が充実してきたら別ページにも保存するかもしれません。&lt;/p&gt;

&lt;h2 id=&#34;シェルスクリプト入門&#34;&gt;シェルスクリプト入門&lt;/h2&gt;

&lt;h3 id=&#34;シェルスクリプトとは&#34;&gt;シェルスクリプトとは&lt;/h3&gt;

&lt;p&gt;シェルスクリプト(shell script)とは、基本的にはシェルを使って実行するコマンドの羅列です。これはテキストファイルに書き込みます。&lt;/p&gt;

&lt;p&gt;まずは、難解なプログラムのイメージではなく、単に各種コマンドをつなぎ合わせたものだと考えてください。このようにイメージすることで、プログラミングに馴染みがない人にも心理的抵抗は少なくなるはずです。&lt;/p&gt;

&lt;p&gt;コマンドの中には構文コマンドなども多数存在しており、わざわざテキストファイルから実行しなくても実行できます。以下は&lt;code&gt;for&lt;/code&gt;文を直接実行した例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ for i in *;do echo ${i%.*} &amp;amp;&amp;amp; pwd;done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;しかし、このようなワンライナー(1行に詰め込まれたコマンドのこと)を何度も直接実行するのは面倒で、かつ解読にも難があることから、テキストファイルに記述して実行することがあります。&lt;/p&gt;

&lt;p&gt;シェルスクリプトは主にこのような目的で作成される事が多いです。&lt;/p&gt;

&lt;p&gt;以下は上記をシェルスクリプト形式で記述した例です。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh
for i in *
do
	echo ${i%.*} \
	&amp;amp;&amp;amp; pwd
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;こちらのほうが何をやっているのか分かりやすいですよね。&lt;/p&gt;

&lt;p&gt;また、当該コマンドを後々何度も実行することが予想される場合、コマンドではなく、シェルスクリプトとして保存しておいたほうが便利になります。何度も難解なコマンドを手動で入力するのは煩雑だからです。&lt;/p&gt;

&lt;h3 id=&#34;シェルとは&#34;&gt;シェルとは&lt;/h3&gt;

&lt;p&gt;シェルスクリプトがコマンドの羅列だとして、シェルとは何でしょう。&lt;/p&gt;

&lt;p&gt;ここで言うシェル(shell)とは、ユーザーが間接的にカーネルとの意思疎通を行うためのツールのことです。具体的には&lt;code&gt;bash&lt;/code&gt;や&lt;code&gt;zsh&lt;/code&gt;, &lt;code&gt;fish&lt;/code&gt;がシェルに該当します。このように、シェルにも様々な種類があり、ユーザーが主に好みによって使用するシェルを選択します。&lt;/p&gt;

&lt;p&gt;また、カーネル(kernel)とはOSの核で、主にハードとソフト(アプリ)の仲介を行います。&lt;/p&gt;

&lt;h3 id=&#34;ターミナルなど&#34;&gt;ターミナルなど&lt;/h3&gt;

&lt;p&gt;シェルを理解する上では、ターミナル(terminal)などの概念も重要になってきます。シェルを自在に操る人は、一般人から見ると真っ黒な画面で何やら怪しげなことをしているコンピューター・ハッカーにしか見えません。&lt;/p&gt;

&lt;p&gt;ここで、真っ黒な画面がターミナルと呼ばれるアプリになります。そして、このターミナルアプリで実行されているのがシェルです。&lt;/p&gt;

&lt;p&gt;シェルを通して処理されるものがコマンドということになります。&lt;/p&gt;

&lt;p&gt;このようにコマンド(文字列)でコンピュータを操作する操作画面のことをCLI(コマンドラインインターフェイス)と言います。&lt;/p&gt;

&lt;p&gt;ハッカー(hacker)が好んで使用するのインターフェイスもこのCLIであることが多いので、一般人の理解も完全に間違っているわけではありません。その認識は概ね正しいといえるでしょう。&lt;/p&gt;

&lt;p&gt;シェルを自在に操るには、コンピュータへの深い理解が必要になることが多いからです。&lt;/p&gt;

&lt;p&gt;そして、ここで言うハッカーとはコンピュータへの深い理解と知識を有した人のことを言います。決してコンピュータを使って悪事を働く人を意味するわけではありません。&lt;/p&gt;

&lt;p&gt;コマンドと言うものは、たった1つでも多くの処理をこなしてしまうため、一見して簡単ですが、危険な面もあるということを覚えておいてください。&lt;/p&gt;

&lt;p&gt;この点、システムやシェルへの理解がないと、間違ったコマンドを実行して大きな過ちを犯してしまう危険があります。&lt;/p&gt;

&lt;p&gt;そして、その範囲は、OSの核であるカーネルとやり取りするだけあって、あまりに膨大です。&lt;/p&gt;

&lt;p&gt;ただし、知っておくべき膨大な知識を前に、失敗するのを怖がっているだけでは何も始まりません。&lt;/p&gt;

&lt;p&gt;私の考えとしては、コマンドの危険性やそのための知識はとりあえず脇に置いておき、まずはコマンドを叩いてみる、そして、それを繋げてみることから始めましょう。&lt;/p&gt;

&lt;p&gt;確かに、失敗するかもしれません。いや、多分するでしょう。しかし、地雷を踏めば踏むほどシステムに詳しくなれると私は考えています。&lt;/p&gt;

&lt;p&gt;例えば、私は、Arch LinuxというOSを使っていますが、Arch Linuxには山ほど地雷があります。ただ、それを踏んだからこそ、少しはコンピュータ(ここではLinux)に詳しくなったのも事実だと感じています。&lt;/p&gt;

&lt;p&gt;さて、失敗を恐れず、いや、失敗を当然の前提として先に進むことにしましょう。&lt;/p&gt;

&lt;h3 id=&#34;manを読むタイミング&#34;&gt;manを読むタイミング&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;man&lt;/code&gt;というマニュアル(ドキュメント)コマンドがあります。ここで&lt;code&gt;man&lt;/code&gt;を読むタイミングについて少しばかり紹介します。&lt;/p&gt;

&lt;p&gt;あなたは、何かを始めようとした時、まず&lt;code&gt;man&lt;/code&gt;を実行することを考えますか?&lt;/p&gt;

&lt;p&gt;ほとんどの人は入門段階では、まずGoogle検索を行うと思います。&lt;/p&gt;

&lt;p&gt;そして、それは概ね正しい判断です。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;man&lt;/code&gt;はつまらない事が多いし、&lt;code&gt;Example&lt;/code&gt;にも対応していないことが多いからです。&lt;/p&gt;

&lt;p&gt;このような理由から、私は&lt;code&gt;man&lt;/code&gt;を読むタイミングは入門を終えた後のほうが良いと考えています。&lt;/p&gt;

&lt;p&gt;CLIに慣れているユーザーは最初に&lt;code&gt;man&lt;/code&gt;を読む人も多いのですが、この記事の読者対象は、あくまで初学者であり、入門者です。&lt;/p&gt;

&lt;p&gt;したがって、いきなり&lt;code&gt;man&lt;/code&gt;を読むことはオススメしませんし、また、&lt;code&gt;man&lt;/code&gt;を読むことがすなわち崇高であることにも結びつきません。&lt;/p&gt;

&lt;p&gt;学び方は人それぞれですし、また、タイミングも人それぞれです。&lt;/p&gt;

&lt;p&gt;自分のレベルに合ったやり方を選択していきましょう。決して背伸びする必要はありませんし、見栄を張る必要もありません。&lt;/p&gt;

&lt;p&gt;ただし、&lt;code&gt;man&lt;/code&gt;は非常に役立つコマンドでもあります。面白くなってきたと感じたら読んでみることをオススメします。これは多くの熟練者達も皆同じだと思います。&lt;/p&gt;

&lt;h3 id=&#34;シェルの種類&#34;&gt;シェルの種類&lt;/h3&gt;

&lt;p&gt;シェルスクリプトを作成するにあたって、まず使用するシェルを決める必要があります。シェルには多くの種類があり、ハードやOSによって搭載されているものが異なります。それぞれに得意不得意があるからです。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;ash&lt;/code&gt;というシェルは&lt;code&gt;busybox&lt;/code&gt;というコマンドパッケージに入っており、小さなハードに組み込まれることが多いシェルです。それだけにミニマムですが、パワーに欠けるかもしれません。&lt;code&gt;bash&lt;/code&gt;や&lt;code&gt;zsh&lt;/code&gt;では直前に実行したコマンドなどを&lt;code&gt;!!&lt;/code&gt;から使えますが、&lt;code&gt;ash&lt;/code&gt;では使えなかった記憶があります。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;ash&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo pacman -S busybox
$ busybox ash
$ echo {直前のコマンド}
$ echo !!
!!
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;bash&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo {直前のコマンド}
$ echo !!
echo {直前のコマンド}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arch Linuxの&lt;code&gt;base&lt;/code&gt;パッケージに&lt;code&gt;bash&lt;/code&gt;シェルが入っています。&lt;code&gt;bash&lt;/code&gt;はLinuxで最も普及しているシェルです。また、&lt;code&gt;sh&lt;/code&gt;というものもありますが、実際この中身が&lt;code&gt;bash&lt;/code&gt;に置き換えられることも多いです。&lt;/p&gt;

&lt;p&gt;私が好んで使用しているシェルは&lt;code&gt;zsh&lt;/code&gt;と言います。これはデフォルトのTab補完が便利であることからとても人気があります。Arch Linuxのインストールディスク(ブートディスク)にも採用されています(ただしbaseには入っていない)。&lt;/p&gt;

&lt;p&gt;なお、私は最近、&lt;code&gt;fish&lt;/code&gt;というシェルも使っています。&lt;code&gt;fish&lt;/code&gt;は補完の他、カラフルなインターフェイスと構文に力を入れているシェルです。&lt;code&gt;fish&lt;/code&gt;は他のシェルとの互換性を損なう場面も多いですが、構文の解読が分かりやすいというメリットがあります。&lt;/p&gt;

&lt;p&gt;ここで、当サイトでは主に&lt;code&gt;zsh&lt;/code&gt;を用いてシェルスクリプトを解説していきます。&lt;/p&gt;

&lt;p&gt;理由としては&lt;code&gt;zsh&lt;/code&gt;の使用者がそこそこいることと、パスの記述が&lt;code&gt;bash&lt;/code&gt;よりも分かりやすいからです。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;bash&lt;/code&gt;と&lt;code&gt;zsh&lt;/code&gt;で実行するシェルスクリプトから絶対パスを取得する記述は以下のようになります。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;bash&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
f=$0
d=$(cd $(dirname $0);pwd)
l=$(cd $(dirname $0);cd ..;pwd)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;zsh&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh
f=$0
d=${0:a:h}
l=${0:a:h:h}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、このような事情から以下のようなコマンドにも違いが出てきます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo https://syui.gitlab.io/shellscript
$ echo !$:t
shellscript
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好みの問題にもなりますが、私は&lt;code&gt;zsh&lt;/code&gt;のほうが好きですね。&lt;/p&gt;

&lt;h3 id=&#34;シェルスクリプトの作成&#34;&gt;シェルスクリプトの作成&lt;/h3&gt;

&lt;p&gt;シェルスクリプトの作成は、通常、シバンから記述します。&lt;/p&gt;

&lt;p&gt;シバン(shebang)というのは、シェルに当該テキストを読み込む実行コマンドを教えるために記述するもので、一般的には&lt;code&gt;#!/path/to/foo&lt;/code&gt;という形で実行ファイルの絶対パスを記述します。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;zsh&lt;/code&gt;でシェルスクリプトを作成したければ、&lt;code&gt;#!/bin/zsh&lt;/code&gt;のように記述します。コマンドの絶対パスは&lt;code&gt;which&lt;/code&gt;コマンドなどから調べることが出来ます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ which zsh
/bin/zsh
or
$ type zsh
zsh is /bin/zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、&lt;code&gt;env&lt;/code&gt;コマンドがあり、これはシバンにするパスを置き換える事ができます。つまり、&lt;code&gt;#!/bin/env zsh&lt;/code&gt;のような記述ができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ which env
/bin/env

&amp;gt; #!/bin/env zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;env&lt;/code&gt;を使用するメリットはシェルのインストール先が環境ごとに異なる場合です。例えば、&lt;code&gt;zsh&lt;/code&gt;が&lt;code&gt;/bin/zsh&lt;/code&gt;と&lt;code&gt;/usr/bin/zsh&lt;/code&gt;にインストールされている環境があったとして、&lt;code&gt;env&lt;/code&gt;で記述することでどちらの環境でも動作します。&lt;/p&gt;

&lt;p&gt;ただし、&lt;code&gt;env&lt;/code&gt;はインタプリタにコマンドライン引数としてオプションを渡すことができないなどのデメリットがあり、特別な事情がない限り&lt;code&gt;env&lt;/code&gt;の使用は推奨しません。&lt;/p&gt;

&lt;p&gt;シバンの後は、コマンドを記述すればシェルスクリプトの完成です。ここでは&lt;code&gt;t.sh&lt;/code&gt;という名前で保存します。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;t.sh&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash
echo &amp;quot;hello world!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;後は実行権限を渡し、&lt;code&gt;t.sh&lt;/code&gt;ファイルを実行します。ファイル権限については後述しますが、&lt;code&gt;x&lt;/code&gt;は実行権限を意味します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ chmod +x t.sh
$ ./t.sh
hello world!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;他にもシェルスクリプトの実行には様々な方法があります。また、&lt;code&gt;zsh -c&lt;/code&gt;などで実行するコマンドは設定ファイルが使われないので、シェルスクリプトを書く際に便利なことがあります。シェルスクリプトを書く時、&lt;code&gt;source&lt;/code&gt;などで環境変数などを読み込むことがあり、それによってコマンドの挙動が変化することがあるので、その回避策として使えます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bash t.sh
$ zsh -c ./t.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;シェルを指定して実行した場合、ファイル自体は指定したシェルが使われますが、テキストの中身はシバンで指定したシェルが使われます。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;t.sh&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh
echo $SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;試しに上記を&lt;code&gt;bash&lt;/code&gt;で実行してみましょう。結果はシェルスクリプト内に書いたコマンドを実行しているシェルになります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ bash t.sh 
/bin/zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ファイルのパーミッション&#34;&gt;ファイルのパーミッション&lt;/h3&gt;

&lt;p&gt;ファイルのパーミッション(権限)には以下の様なものが一般的です。ディレクトリも厳密にはファイルの一種なのでパーミッションがあります。基本的には&lt;code&gt;x=実行&lt;/code&gt;, &lt;code&gt;r=読み込み&lt;/code&gt;, &lt;code&gt;w=書き込み&lt;/code&gt;を意味します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# タイムスタンプの書き換え
$ touch -t 000001010000 *

# パーミッションの確認
$ ls -l
4.0K -rwxr-xr-x 1 syui staff  35  1  1  0000 t.sh

# パーミッションの付与(すべてのユーザーはa+)
$ chmod a+rwx t.sh
4.0K -rwxrwxrwx 1 syui staff  35  1  1  0000 t.sh

# パーミッションの削除
$ chmod a-rwx t.sh
4.0K ---------- 1 syui staff  35  1  1  0000 t.sh

# 実行権限のみ付与
$ chmod +x t.sh
4.0K ---x--x--x 1 syui staff  35  1  1  0000 t.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで&lt;code&gt;chmod&lt;/code&gt;コマンドは&lt;code&gt;a+&lt;/code&gt;がすべてのユーザーを対象にします。&lt;code&gt;u+&lt;/code&gt;がユーザーで&lt;code&gt;g+&lt;/code&gt;がグループ, &lt;code&gt;o+&lt;/code&gt;がその他です。指定しないとユーザー&lt;code&gt;u+&lt;/code&gt;になります。&lt;/p&gt;

&lt;p&gt;ディレクトリのパーミッションを変更したければ、以下のように&lt;code&gt;-R&lt;/code&gt;を使います。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ chmod -R +x .
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;パスについて&#34;&gt;パスについて&lt;/h3&gt;

&lt;p&gt;基本的なパスの概念は絶対パスと相対パスがあります。絶対パスはルートディレクトリから数えたパスで、相対パスは現在地から数えたパスです。&lt;/p&gt;

&lt;p&gt;以下、具体例を示します。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;現在場所 : &lt;code&gt;~/git/shell/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;絶対パス : &lt;code&gt;$ /home/syui/git/shell/t.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;相対パス : &lt;code&gt;$ ./t.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;そして、パスを通すという言葉があります。この言葉は環境変数である&lt;code&gt;PATH&lt;/code&gt;にパスを追加する事を意味します。パスを通すと、そのディレクトリ内にあるファイルはパスの記述なしに実行できるようになります。&lt;/p&gt;

&lt;p&gt;本当にパスの記述が不要になるか各々試してみましょう。ここでは&lt;code&gt;t.sh&lt;/code&gt;がある&lt;code&gt;~/git/shell&lt;/code&gt;をPATHに追加することにします。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pwd
/home/syui/git/shell

$ echo $PATH
/bin:/usr/bin

$ export PATH=$PATH:`pwd`

$ echo $PATH
/bin:/usr/bin:/home/syui/git/shell

$ cd

$ pwd
/home/syui

$ t.sh
hello world!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;様々な記述&#34;&gt;様々な記述&lt;/h3&gt;

&lt;p&gt;上記ではホームディレクトリを&lt;code&gt;~&lt;/code&gt;と&lt;code&gt;/home/syui&lt;/code&gt;で表しています。このように、ホームディレクトリは&lt;code&gt;~&lt;/code&gt;に省略できます。他にも様々な省略記法がシェルには用意されています。これはシェルによって変わってきますが、基本的なものは大体同じです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo ~
/home/syui

$ echo ^
t.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;変数&#34;&gt;変数&lt;/h3&gt;

&lt;p&gt;シェルには最初から定義されている変数が幾つかあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 現在使用しているシェルを調べる
$ echo $SHELL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで、変数の使い方は代入及び出力で理解できると思います。使用した文字列の先頭に&lt;code&gt;$&lt;/code&gt;を付けると変数を使えます。また、他の文字列と連結することによって違う意味になることがあるので、確実な変数の使用のためには&lt;code&gt;${x}&lt;/code&gt;というように括弧でくくるとより確実です。この辺はケースバイケースで考えましょう。必ずしも括弧に入れる必要はありません。なお、&lt;code&gt;export&lt;/code&gt;コマンドは省略できます。ただし、&lt;code&gt;export&lt;/code&gt;コマンドで代入することでグローバル変数にすることができ、環境が変わっても参照できるようになります。より確実に参照したい場合は&lt;code&gt;export&lt;/code&gt;で代入するのが良いかもしれません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 代入
$ export a=foo
or
$ a=foo

# 出力
$ echo $a
foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで、代入というのは中身を書き換えるようなイメージです。例えば、&lt;code&gt;a&lt;/code&gt;に&lt;code&gt;test&lt;/code&gt;を代入する場合、&lt;code&gt;$ a=test&lt;/code&gt;というコマンドを実行することになります。実行すると変数&lt;code&gt;a&lt;/code&gt;の中身は&lt;code&gt;test&lt;/code&gt;に変わります。変数というのは、このように中身を自在に書き換えて使うことが出来ます。何が便利なのかというと、何度も利用する事ができる点です。&lt;/p&gt;

&lt;p&gt;例えば、&lt;code&gt;test&lt;/code&gt;という文字列を10回出力したいとします。この場合、わざわざ&lt;code&gt;test&lt;/code&gt;を10回書くよりも変数に入れて使用した方が効率が良くなります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh
a=test
for ((i=1;i&amp;lt;=10;i++))
do
	echo $a
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;なお、以下のように指定回数コマンドを実行することもできます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ export a=test
$ zsh -c &amp;quot;repeat 10 echo $a&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;改行を含めた変数&#34;&gt;改行を含めた変数&lt;/h4&gt;

&lt;p&gt;ここはシェルスクリプトのマハリどころなのですが、変数には改行を含めることができます。&lt;/p&gt;

&lt;p&gt;ただし、それを参照する場合は、ダブルクオーテーションで囲まなければならないことがあります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo -e &amp;quot;test\nshell&amp;quot;
test
shell

$ a=!$

$ echo $a
testshell

$ echo &amp;quot;$a&amp;quot;
test
shell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;もちろん、ダブルクオーテーションで囲まなくても改行が含まれる場合もあり、この辺はどのような理由で含まれなかったり、含まれたりするのかよく分かりません。よって、確実に改行を含めたい場面では、ダブルクオーテーションを使うようにしています。&lt;/p&gt;

&lt;h3 id=&#34;文字列比較など&#34;&gt;文字列比較など&lt;/h3&gt;

&lt;p&gt;文字列比較や変数が空かどうか調べるにもダブルクオーテーションが必要になることがあります。以下は引数があればそれを出力する内容になっています。もし引数がなければ&lt;code&gt;error&lt;/code&gt;を表示します。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;t.sh&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh
if [ -n &amp;quot;$1&amp;quot; ];then
	echo $1
else
	echo error
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./t.sh 
error

$ ./t.sh good!
good!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;シングルクォーテーションとダブルクオーテーション&#34;&gt;シングルクォーテーションとダブルクオーテーション&lt;/h3&gt;

&lt;p&gt;ダブルクオーテーション&lt;code&gt;&amp;quot;&lt;/code&gt;とシングルクォーテーション&lt;code&gt;&#39;&lt;/code&gt;の使い分けについてです。&lt;/p&gt;

&lt;p&gt;基本的にはダブルは変数を使うことが出来ますが、シングルは変数が使えません(書き方にもよりますが)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ a=test

$ echo &#39;$a&#39;
$a

$ echo &amp;quot;$a&amp;quot;
test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、ダブルの中でダブルを使いたい場合などは手前に&lt;code&gt;\&lt;/code&gt;を記述することで解決できます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ echo &amp;quot;\&amp;quot;$a\&amp;quot;&amp;quot;
&amp;quot;test&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;私は、そのままの文字列を使いたい場合、シングルを使うようにしています。それ以外ではダブルを使うことが多いです。&lt;/p&gt;

&lt;p&gt;ちなみに、このようなテクニックは変数に代入するときにも使えます。&lt;/p&gt;

&lt;h3 id=&#34;シェルスクリプトの文法&#34;&gt;シェルスクリプトの文法&lt;/h3&gt;

&lt;p&gt;シェルスクリプトの文法は他のスクリプト言語に比べて非常に簡素で、かつ馴染みにくいものかもしれません。&lt;/p&gt;

&lt;p&gt;ただ、一つのコマンドとして捉えると分かりやすく、そして、納得できるものでもあります。&lt;/p&gt;

&lt;p&gt;言語的には推測が難しい側面がありますが、コマンドやコマンドオプション的には推測が可能です。&lt;/p&gt;

&lt;p&gt;そのあたりを意識して、シェルスクリプトで使われる一般的な文法表現について見ていくことにします。&lt;/p&gt;

&lt;h4 id=&#34;if-文の使用例&#34;&gt;if 文の使用例&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh

# コメント
a=0
if [ $a -eq 0 ];then
	echo &amp;quot;ok.&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;計算や比較の条件式には&lt;code&gt;[]&lt;/code&gt;を使います。注意点としてスペースが必要になります。これらも一つのコマンドです。&lt;code&gt;-eq&lt;/code&gt;は同じ数値であるか比較するオプションです。&lt;/p&gt;

&lt;p&gt;ここで、&lt;code&gt;;&lt;/code&gt;の意味はコマンドの終わりや改行を意味します。&lt;code&gt;then&lt;/code&gt;は条件の終わりを意味します。つまり、以下のように書いても同じ内容になります。ちなみに、&lt;code&gt;fi&lt;/code&gt;は&lt;code&gt;if&lt;/code&gt;文の終わりですね。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh

a=0
if [ $a -eq 0 ]
then
	echo &amp;quot;ok.&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、単純に条件処理をしたい場合は、括弧を使わず&lt;code&gt;if&lt;/code&gt;のみで判定することもできます。&lt;/p&gt;

&lt;p&gt;例えば、コマンドが成功した場合の処理は以下のようになります。つまり、条件に&lt;code&gt;if ~&lt;/code&gt;以降に記述されるコマンドの成否を設定しているわけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh

if echo 0 | grep 0;then
	echo &amp;quot;$?&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、条件の追加&lt;code&gt;elif&lt;/code&gt;や条件に当てはまらない場合の処理&lt;code&gt;else&lt;/code&gt;を書くことができます。注意点として、文字列比較は必ずダブルでもシングルでも良いので、クォーテーションを付けなければなりません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/zsh

str=test
if [ &amp;quot;$str&amp;quot; = &amp;quot;foo&amp;quot; ];then
  echo &amp;quot;foo&amp;quot;
elif [ &amp;quot;$str&amp;quot; = &amp;quot;bar&amp;quot; ];then
  echo &amp;quot;bar&amp;quot;
else
  echo &amp;quot;unset&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;条件を反転させる場合は、大抵、&lt;code&gt;!&lt;/code&gt;を付けることで解決できます。この例では、&lt;code&gt;a&lt;/code&gt;でない時に条件が満たされます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;if [ &amp;quot;a&amp;quot; != &amp;quot;b&amp;quot; ];then
	:
fi
if !echo a|grep b;then
	:
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;test&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>